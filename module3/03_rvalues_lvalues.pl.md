## PrzesuÅ„ semantykÄ™

### Uzasadnienie

* Lepsza optymalizacja dziÄ™ki unikaniu zbÄ™dnych kopii
* zwiÄ™kszone bezpieczeÅ„stwo dziÄ™ki zachowaniu tylko jednej instancji

___

## Nowe elementy skÅ‚adni

* <!-- .element: class="fragment fade-in" --> <code>auto && value</code> - odniesienie do wartoÅ›ci r
* <!-- .element: class="fragment fade-in" --> <code>Class(Class &&)</code> - konstruktor ruchu
* <!-- .element: class="fragment fade-in" --> <code>Class& operator=(Class&&)</code> - operator przypisania ruchu
* <!-- .element: class="fragment fade-in" --> <code>std::move()</code> funkcja pomocnicza
* <!-- .element: class="fragment fade-in" --> <code>std::forward()</code> funkcja pomocnicza
____
## rwartoÅ›Ä‡ i lwartoÅ›Ä‡

```cpp
struct A { int a, b; };

A foo() { return {1, 2}; }

A a;                    // l-value
A{5, 3};                // r-value
foo();                  // r-value
```

___

## wartoÅ›Ä‡ r i wartoÅ›Ä‡ l

* <!-- .element: class="fragment fade-in" --> Obiekt wartoÅ›ci l ma nazwÄ™ i adres
* <!-- .element: class="fragment fade-in" --> Obiekt wartoÅ›ci l jest trwaÅ‚y, w nastÄ™pnej linii moÅ¼na uzyskaÄ‡ do niego dostÄ™p po nazwie
* <!-- .element: class="fragment fade-in" --> Obiekt wartoÅ›ci r nie ma nazwy (zwykle) ani adresu
* <!-- .element: class="fragment fade-in" --> Obiekt wartoÅ›ci r jest tymczasowy, w nastÄ™pnej linii nie bÄ™dzie dostÄ™pny

___

## Odniesienia do wartoÅ›ci r i l

```cpp
struct A { int a, b; };
A foo() { return {1, 2}; }

A a;                    // l-value
A{5, 3};                // r-value
foo();                  // r-value

A & ra = a;             // l-value reference to l-value, OK
A & rb = foo();         // l-value reference to r-value, ERROR
A const& rc = foo();    // const l-value reference to r-value, OK (exception)

A && rra = a;           // r-value reference to l-value, ERROR
A && rrb = foo();       // r-value reference to r-value, OK

A const ca{20, 40};
A const&& rrc = ca;     // const r-value reference to const l-value, ERROR
```

___

## wartoÅ›Ä‡ r czy wartoÅ›Ä‡ l?

<pre><code class="cpp" data-trim data-noescape>
str1 += str2                    <span class="fragment">// l-value</span>
str1 + str2                     <span class="fragment">// r-value</span>
[](int x){ return x * x; };     <span class="fragment">// r-value</span>
std::move(a);                   <span class="fragment">// r-value</span>
int && a = 4;                   <span class="fragment">// 4 is r-value</span>
</code></pre>

___

## odniesienie do wartoÅ›ci r to ... wartoÅ›Ä‡ l?

### `int && a = 4;`

* <!-- .element: class="fragment fade-in" --> <code>4</code> jest wartoÅ›ciÄ… r
* <!-- .element: class="fragment fade-in" --> <code>a</code> jest odniesieniem do wartoÅ›ci r
* <!-- .element: class="fragment fade-in" --> imiÄ™ <code>a</code> sama jest wartoÅ›ciÄ… l (ma adres, moÅ¼na siÄ™ do niej odwoÅ‚ywaÄ‡ pÃ³Åºniej)
* <!-- .element: class="fragment fade-in" --> ale nie myÅ›lmy o tym teraz ğŸ˜‰

___

<!-- .slide: data-background-iframe="https://en.cppreference.com/w/cpp/language/value_category" data-background-interactive -->

<div class="box" style="position: absolute; width: 45%; right: 0; background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 20px; font-size: 20px; text-align: left;">
    <h2> Kategorie wartoÅ›ci w C ++ </h2>
    <ul>
        <li> lwartoÅ›Ä‡ </li>
        <li> prvalue </li>
        <li> xvalue </li>
        <li> glvalue = lvalue | xvalue </li>
        <li> rvalue = prvalue | xvalue </li>
    </ul>
    <p><a href="https://en.cppreference.com/w/cpp/language/value_category">PeÅ‚na lista na cppreference.com</a></p>
</div>
