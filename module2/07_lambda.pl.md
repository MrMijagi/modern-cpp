<!-- .slide: data-background="#111111" -->
# Wyrażenia lambda w skrócie

___

## Wyrażenia lambda

**Racjonalne uzasadnienie**: programowanie funkcjonalne, funkcje w miejscu, bardziej uniwersalne przekazywanie funkcji
<!-- .element: class="fragment fade-in" -->

Wyrażenia lambda są definiowane bezpośrednio w miejscu ich użycia. Zwykle jest używany jako parametr innej funkcji, która oczekuje od wskaźnika do funkcji lub funktora - na ogół jest to obiekt wywoływalny.
<!-- .element: class="fragment fade-in" -->

Każde wyrażenie lambda powoduje, że kompilator tworzy unikalną klasę zamknięcia, która implementuje operator funkcji z kodem z wyrażenia.
<!-- .element: class="fragment fade-in" -->

Zamknięcie jest przedmiotem klasy zamknięcia. Zgodnie z typem przechwytywania obiekt ten przechowuje odniesienia lub kopie zmiennych lokalnych.
<!-- .element: class="fragment fade-in" -->

___

## Podstawowe wyrażenia lambda

```c++
[](){}; // empty lambda
[] { std::cout << "hello world" << std::endl; } // unnamed lambda

auto l = [] (int x, int y) { return x + y; };
auto result = l(2, 3); // result = 5
```

___

## Zwrócony typ lambdy

Z C ++ 14 automatyczne odejmowanie typu zwracanego z lambd działa całkiem nieźle i zwykle nie ma potrzeby bezpośredniego podawania zwracanego typu. Można to jednak zrobić za pomocą operatora strzałki.
<!-- .element: class="fragment fade-in" -->

```c++
[](bool condition) -> int {
    if (condition) {
        return 1;
    } else {
        return 2;
    }
}
```
<!-- .element: class="fragment fade-in" -->

___

## Predykaty

Wyrażenia lambda są zwykle używane do tworzenia predykatów i funktorów wymaganych przez algorytmy w standardowej bibliotece (np `std::sort`).
<!-- .element: class="fragment fade-in" -->

```c++

std::array<double, 6> values = { 5.0, 4.0, -1.4, 7.9, -8.22, 0.4 };

std::sort(values.begin(), values.end(), [](double a, double b) {
    return std::abs(a) < std::abs(b); //sort values using
                                      //absolute values
});
```
<!-- .element: class="fragment fade-in" -->

Wynik: `0.4, -1.4, 4.0, 5.0, 7.9, -8.22`
<!-- .element: class="fragment fade-in" -->

___
<!-- .slide: style="font-size: 0.9em" -->

## Lista przechwytywania

Wewnątrz `[]` w nawiasach możemy zawrzeć elementy, które lambda powinna wychwycić z zakresu, w jakim jest tworzona. Można również określić sposób ich przechwytywania.

* <!-- .element: class="fragment fade-in" --> <code>[]</code> puste nawiasy oznaczają, że wewnątrz lambdy nie można użyć żadnej zmiennej z zewnętrznego zakresu.
* <!-- .element: class="fragment fade-in" --> <code>[&]</code> oznacza, że ​​każda zmienna z zakresu zewnętrznego jest przechwytywana przez odwołanie, w tym `this` wskaźnik.
  * Funktor utworzony za pomocą wyrażenia lambda może czytać i zapisywać do dowolnej przechwyconej zmiennej i wszystkie są przechowywane wewnątrz przez odniesienie lambda.
* <!-- .element: class="fragment fade-in" --> <code>[=]</code> oznacza, że ​​każda zmienna z zakresu zewnętrznego jest przechwytywana według wartości, w tym `this` wskaźnik.
  * Wszystkie używane zmienne z zewnętrznego zakresu są kopiowane do wyrażenia lambda i mogą być tylko odczytywane z wyjątkiem `this` wskaźnik.
  * `this` wskaźnik po skopiowaniu pozwala lambdzie zmodyfikować wszystkie zmienne, na które wskazuje.
  * Potrzebujesz `mutable` słowo kluczowe, aby zmodyfikować wartości przechwycone przez `=`.
* <!-- .element: class="fragment fade-in" --> <code>[capture-list]</code> umożliwia jawne przechwytywanie zmiennych z zewnętrznego zakresu poprzez wymienienie ich nazw na liście.
  * Domyślnie wszystkie elementy są przechwytywane według wartości.
  * Jeśli zmienna ma zostać ujęta przez odniesienie, należy to wykluczyć `&` co oznacza wychwytywanie przez odniesienie. * Przykład: `[a, &b]`
* <!-- .element: class="fragment fade-in" --> <code>[*this]</code> (C ++ 17) przechwytuje ten wskaźnik według wartości (tworzy kopię tego obiektu).

___

## Lista przechwytywania

```c++
int a {5};
auto add5 = [=](int x) { return x + a; };

int counter {};
auto inc = [&counter] { counter++; };

int even_count = 0;
for_each(v.begin(), v.end(), [&even_count] (int n) {
    cout << n;
    if (n % 2 == 0)
        ++even_count;
});

cout << "There are " << even_count
     << " even numbers in the vector." << endl;
```

___
<!-- .slide: style="font-size: 0.95em" -->

## Ogólne lambdy (C ++ 14)

W C ++ 11 parametry wyrażenia lambda muszą być zadeklarowane przy użyciu określonego typu.

C ++ 14 pozwala zadeklarować parametr jako `auto`.

Pozwala to kompilatorowi wydedukować typ parametru lambda w taki sam sposób, w jaki wyprowadza się parametry szablonów. W rezultacie kompilator generuje kod odpowiadający klasie zamknięcia podanej poniżej:

```c++
auto lambda = [](auto x, auto y) { return x + y; }

struct UnnamedClosureClass {// code generated by the compiler for above 1 line
    template <typename T1, typename T2>
    auto operator()(T1 x, T2 y) const {
        return x + y;
    }
};
auto lambda = UnnamedClosureClass();
```

___

## Wyrażenia przechwytywania lambda (C ++ 14)

Funkcje lambda języka C ++ 11 przechwytują zmienne zadeklarowane w ich zewnętrznych zakresach przez kopiowanie wartości lub odwołanie. Oznacza to, że elementy składowe wartości lambda nie mogą być typami tylko do przenoszenia.

C ++ 14 umożliwia inicjalizację przechwyconych elementów członkowskich za pomocą dowolnych wyrażeń. Umożliwia to zarówno przechwytywanie przez przenoszenie wartości, jak i deklarowanie dowolnych elementów składowych lambda, bez posiadania odpowiednio nazwanej zmiennej w zakresie zewnętrznym.

```c++
auto lambda = [value = 1] { return value; };

std::unique_ptr<int> ptr(new int(10));
auto anotherLambda = [value = std::move(ptr)] { return *value; };
```

___

## Ćwiczenie

Zmień funkcje z `main.cpp` na lambdy (`sortByArea`, `perimeterBiggerThan20`, `areaLessThan10`)

Zmień lambdę `areaLessThan10` na lambdę `areaLessThanX`, które wymaga `x = 10` na liście przechwytywania. Jaki jest problem?

Posługiwać się `std::function` rozwiązać problem.
