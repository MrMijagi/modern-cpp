<!-- .slide: data-background="#111111" -->
# Lambda expressions in short

___

## Lambda expressions

**Rationale**: functional programming, in-place functions, more universal function passing
<!-- .element: class="fragment fade-in" -->

Lambda expressions is defined directly in-place of its usage. Usually it is used as a parameter of another function that expects pointer to function or functor - in general a callable object.
<!-- .element: class="fragment fade-in" -->

Every lambda expression cause the compiler to create unique closure class that implements function operator with code from the expression.
<!-- .element: class="fragment fade-in" -->

Closure is an object of closure class. According to way of capture type this object keeps references or copies of local variables.
<!-- .element: class="fragment fade-in" -->

___

## Basic lambda expressions

```c++
[](){}; // empty lambda
[] { std::cout << "hello world" << std::endl; } // unnamed lambda

auto l = [] (int x, int y) { return x + y; };
auto result = l(2, 3); // result = 5
```

___

## Lambda's returned type

From C++14 automatic return type deduction from lambdas works quite good and usually there is no need to tell the returned type directly. However, it can be done using arrow operator.
<!-- .element: class="fragment fade-in" -->

```c++
[](bool condition) -> int {
    if (condition) {
        return 1;
    } else {
        return 2;
    }
}
```
<!-- .element: class="fragment fade-in" -->

___

## Predicates

Lambda expressions are usually used to create predicates and functors required by algorithms in standard library (e.g. for `std::sort`).
<!-- .element: class="fragment fade-in" -->

```c++

std::array<double, 6> values = { 5.0, 4.0, -1.4, 7.9, -8.22, 0.4 };

std::sort(values.begin(), values.end(), [](double a, double b) {
    return std::abs(a) < std::abs(b); //sort values using
                                      //absolute values
});
```
<!-- .element: class="fragment fade-in" -->

Output: `0.4, -1.4, 4.0, 5.0, 7.9, -8.22`
<!-- .element: class="fragment fade-in" -->

___
<!-- .slide: style="font-size: 0.9em" -->

## Capture list

Inside `[]` brackets we can include elements that the lambda should capture from the scope in which it is created. Also, the way how they are captured can be specified.

* <!-- .element: class="fragment fade-in" --> <code>[]</code> empty brackets means that inside the lambda no variable from outer scope can be used.
* <!-- .element: class="fragment fade-in" --> <code>[&]</code> means that every variable from outer scope is captured by reference, including `this` pointer.
  * Functor created by lambda expression can read and write to any captured variable and all of them are kept inside by lambda reference.
* <!-- .element: class="fragment fade-in" --> <code>[=]</code> means that every variable from outer scope is capture by value, including `this` pointer.
  * All used variables from the outer scope are copied to lambda expression and can be read only except for `this` pointer.
  * `this` pointer when copied allows lambda to modify all variables it points to.
  * You need a `mutable` keyword to modify values captured by `=`.
* <!-- .element: class="fragment fade-in" --> <code>[capture-list]</code> allows to explicitly capture variable from the outer scope by mentioning their names on the list.
  * By default all elements are captured by value.
  * If variable should be captured by reference it should be precided by `&` whitch means capturing by reference.
  * Example: `[a, &b]`
* <!-- .element: class="fragment fade-in" --> <code>[*this]</code> (C++17) captures this pointer by value (creates a copy of this object).

___

## Capture list

```c++
int a {5};
auto add5 = [=](int x) { return x + a; };

int counter {};
auto inc = [&counter] { counter++; };

int even_count = 0;
for_each(v.begin(), v.end(), [&even_count] (int n) {
    cout << n;
    if (n % 2 == 0)
        ++even_count;
});

cout << "There are " << even_count
     << " even numbers in the vector." << endl;
```

___
<!-- .slide: style="font-size: 0.95em" -->

## Generic lambdas (C++14)

In C++11 parameters of lambda expression must be declared with use of specific type.

C++14 allows to declare parameter as `auto`.

This allows a compiler to deduce the type of lambda parameter in the same way parameters of the templates are deduced. In result compiler generates a code equivalent to closure class given below:

```c++
auto lambda = [](auto x, auto y) { return x + y; }

struct UnnamedClosureClass {// code generated by the compiler for above 1 line
    template <typename T1, typename T2>
    auto operator()(T1 x, T2 y) const {
        return x + y;
    }
};
auto lambda = UnnamedClosureClass();
```

___

## Lambda capture expressions (C++14)

C++11 lambda functions capture variables declared in their outer scopes by value-copy or by reference. This means that a value members of a lambda cannot be move-only types.

C++14 allows captured members to be initialized with arbitrary expressions. This allows both capture by value-move and declaring arbitrary members of the lambda, without having a correspondingly named variable in an outer scope.

```c++
auto lambda = [value = 1] { return value; };

std::unique_ptr<int> ptr(new int(10));
auto anotherLambda = [value = std::move(ptr)] { return *value; };
```

___

## Exercise

Change functions from `main.cpp` into lambdas (`sortByArea`, `perimeterBiggerThan20`, `areaLessThan10`)

Change lambda `areaLessThan10` into lambda `areaLessThanX`, which takes `x = 10` on a capture list. What is the problem?

Use `std::function` to solve the problem.
